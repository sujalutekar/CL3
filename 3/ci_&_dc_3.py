# -*- coding: utf-8 -*-
"""CI & DC 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kZEXYXSBbr8OtPbBDzEA3zwcnqQns8Wv
"""

# AIM: Write code to simulate requests coming from clients and distribute them among the servers
# using the load balancing algorithms.



# A load balancing algorithm is the logic or rule that decides which server should handle each incoming request.

# List of servers
servers = ["Server1", "Server2", "Server3"]

# Client requests (10 clients)
requests = ["Client1", "Client2", "Client3", "Client4", "Client5", "Client6", "Client7", "Client8", "Client9", "Client10"]

# -------- Round Robin --------

# It assigns requests to servers in order one by one.
# After the last server, it starts again from the first.
# It doesn’t care about current load.

def round_robin(requests, servers):
    print("\n--- Round Robin ---")
    server_index = 0
    for req in requests:
        print(f"{req} → {servers[server_index]}")
        server_index = (server_index + 1) % len(servers)

# -------- Least Connections --------

# It looks at all servers and picks the one with the fewest current connections.
# This balances load smartly by checking the real-time load.

def least_connections(requests, servers):
    print("\n--- Least Connections ---")
    server_counts = {server: 0 for server in servers}
    for req in requests:
        least_busy_server = min(server_counts, key=server_counts.get)
        print(f"{req} → {least_busy_server}")
        server_counts[least_busy_server] += 1


round_robin(requests, servers)
least_connections(requests, servers)





# 1. Round Robin Algorithm Explanation

  # Round Robin is a very simple algorithm. It sends requests to servers in a circular order,
  # without considering the load of the servers. It simply goes in order and repeats after the last server.

  # server_index = 0 initializes the first server (Server1).

  # The "for req in requests" loop goes through all the client requests one by one.

  # print(f"{req} → {servers[server_index]}"): For each client request, it prints
  # the request and the server it is being sent to.

  # server_index = (server_index + 1) % len(servers): After every request,
  # server_index increases by 1 to go to the next server.

  # The " % len(servers) " ensures that when the index reaches the last
  # server (e.g., Server3), it will go back to the first server (Server1).


# 2. Least Connections Algorithm Explanation

  # Least Connections assigns each request to the server with the fewest active requests.

  # It uses a counter (server_counts) to track how many requests each server is handling.

  # For each request, it finds the server with the least load using min().

  # After assigning the request, it updates the server's request count.