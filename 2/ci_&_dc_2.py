# -*- coding: utf-8 -*-
"""CI & DC 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1owiZuhhGYJAA4ZKkrqGbov4xy78fPvpk
"""

# AIM: Implement Union, Intersection, Complement and Difference operations on fuzzy sets. Also
# create fuzzy relations by Cartesian product of any two fuzzy sets and perform max-min
# composition on any two fuzzy relations


# Fuzzy sets as lists
A = [0.2, 0.7, 1.0]
B = [0.5, 0.4, 0.9]

# Union: max(A, B)
def union(A, B):
    return [max(a, b) for a, b in zip(A, B)]   # zip(A, B) pairs up elements at same index

# Intersection: min(A, B)
def intersection(A, B):
    return [min(a, b) for a, b in zip(A, B)]

# Complement: 1 - A
def complement(A):
    return [1 - a for a in A]

# Difference: min(A, 1 - B)
def difference(A, B):
    return [min(a, 1 - b) for a, b in zip(A, B)]

# Cartesian product (A x B)
def cartesian_product(A, B):
    return [[min(a, b) for b in B] for a in A] # Why "min" used here: The strength of the relationship is limited by the weaker one.

# Max-min composition
def max_min_composition(R1, R2):
    result = []
    for i in range(len(R1)):
        row = []
        for j in range(len(R2[0])):
            max_val = 0
            for k in range(len(R2)):
                max_val = max(max_val, min(R1[i][k], R2[k][j]))
            row.append(max_val)
        result.append(row)
    return result


# ------------------- Output -------------------

print("Union:", union(A, B))
print("Intersection:", intersection(A, B))
print("Complement of A:", complement(A))
print("Difference (A - B):", difference(A, B))

R1 = cartesian_product(A, B)
R2 = cartesian_product(B, A)

print("Cartesian Product (A x B):")
for row in R1:
    print(row)

print("Max-Min Composition:")
comp = max_min_composition(R1, R2)
for row in comp:
    print(row)






# How Max-min composition works (step-by-step):
  # For each row i in R1 and column j in R2,
  # it tries all k values (middle links).

  # For each k, it calculates:
  # → min(R1[i][k], R2[k][j]) (weakest link in that path)

  # Then it finds the maximum of all those mins.
  # → That becomes the final value at position [i][j].