# -*- coding: utf-8 -*-
"""CI & DC 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d8zkkgXWiJIkT8yFvhMydWLT7Z4sz--V
"""

# AIM: Optimization of genetic algorithm parameter in hybrid genetic algorithm-neural network
# modelling: Application to spray drying of coconut milk.



import random
import numpy as np # type: ignore

# Fitness Function
def evaluate_fitness(weights):
    return 1 / (1 + np.sum(np.square(weights - 0.5)))  # Best fitness when weights ~0.5

# Genetic Algorithm Parameters
POP_SIZE = 10  # The population size is the number of individuals (solutions) in each generation of the GA.
CHROMO_LENGTH = 5  # The chromosome length defines how many parameters (weights) each individual will have. Here, each chromosome has 5 values (5 weights).
MUTATION_RATE = 0.1  # The probability of randomly changing a gene in the chromosome during the mutation step. Here, itâ€™s set to 0.1 (i.e., 10% chance).
CROSSOVER_RATE = 0.8  # The probability that two chromosomes will undergo a crossover operation to produce offspring.
GENERATIONS = 20  # The number of generations (iterations) the algorithm will run.

# Generate initial population.
# init_population: This function generates the initial population. For each individual in the population, it creates a random chromosome (a set of weights).
def init_population():
    return [np.random.rand(CHROMO_LENGTH) for _ in range(POP_SIZE)]

# Crossover two parents.
# Crossover is a genetic operation where two parent chromosomes exchange genetic material to create new offspring.
def crossover(p1, p2):
    if random.random() < CROSSOVER_RATE:
        point = random.randint(1, CHROMO_LENGTH - 1)
        child1 = np.concatenate((p1[:point], p2[point:]))
        child2 = np.concatenate((p2[:point], p1[point:]))
        return child1, child2
    return p1, p2

# Mutate a chromosome
# Mutation randomly alters/mutates one or more genes (values) in the chromosome. The probability of mutation is determined by the MUTATION_RATE (10% here).
def mutate(chromo):
    for i in range(CHROMO_LENGTH):
        if random.random() < MUTATION_RATE:
            chromo[i] = random.random()
    return chromo

# Genetic Algorithm loop
def genetic_algorithm():
    population = init_population()
    best_fitness = 0
    best_solution = None

    for gen in range(GENERATIONS):
        fitness_scores = [evaluate_fitness(ind) for ind in population]
        sorted_indices = np.argsort(fitness_scores)[::-1]
        population = [population[i] for i in sorted_indices]

        if fitness_scores[sorted_indices[0]] > best_fitness:
            best_fitness = fitness_scores[sorted_indices[0]]
            best_solution = population[0]

        print(f"Generation { gen+1 }   |   Best Fitness: {best_fitness:.4f}")

        new_population = population[:2]  # Elitism

        while len(new_population) < POP_SIZE:
            p1, p2 = random.sample(population[:5], 2)  # Top 5 selection
            c1, c2 = crossover(p1, p2)
            new_population.append(mutate(c1))
            if len(new_population) < POP_SIZE:
                new_population.append(mutate(c2))

        population = new_population

    print("\nOptimized Weights:", np.round(best_solution, 3))
    print("Simulated Coconut Milk Spray Drying Accuracy:", round(best_fitness * 100, 2), "%")

genetic_algorithm()